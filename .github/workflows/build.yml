name: Build

on:
  push:
    tags:
      - '*'
    branches: [ master, main ]
  pull_request:
    branches: [ master, main ]
  workflow_dispatch: {}

permissions:
  contents: write
  actions: read

env:
  BUILD_TYPE: Release

jobs:
  build:
    name: ${{ matrix.config.name }}
    runs-on: ${{ matrix.config.os }}
    strategy:
      matrix:
        config:
          - { name: "Ubuntu gcc", os: "ubuntu-22.04", generator: "Unix Makefiles", cc: "gcc", cxx: "g++" }
          - { name: "Ubuntu clang", os: "ubuntu-22.04", generator: "Unix Makefiles", cc: "clang", cxx: "clang++" }
          - { name: "macOS clang", os: "macos-latest", generator: "Unix Makefiles", cc: "clang", cxx: "clang++", cmake_flags: "-DCMAKE_OSX_ARCHITECTURES='x86_64;arm64' -DCMAKE_OSX_DEPLOYMENT_TARGET=14" }
          - { name: "Windows clang", os: "windows-2022", generator: "Unix Makefiles", cc: "clang", cxx: "clang++" }
          - { name: "Windows MSVC", os: "windows-2022", generator: "Visual Studio 17 2022" }

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Configure CMake
        run: cmake -B "${{ github.workspace }}/build" -G "${{ matrix.config.generator }}" -DCMAKE_BUILD_TYPE=${{ env.BUILD_TYPE }} -DARMIPS_USE_STD_FILESYSTEM=ON -DCMAKE_INSTALL_PREFIX="${{ github.workspace }}/install" ${{ matrix.config.cmake_flags }}
        env:
          CC: ${{ matrix.config.cc }}
          CXX: ${{ matrix.config.cxx }}

      - name: Build
        run: cmake --build "${{ github.workspace }}/build" --config ${{ env.BUILD_TYPE }}

      - name: Test
        working-directory: ${{ github.workspace }}/build
        run: ctest -C ${{ env.BUILD_TYPE }} --output-on-failure

      - name: Install
        shell: bash
        run: |
          cmake --build "${{ github.workspace }}/build" --config ${{ env.BUILD_TYPE }} --target install
          # create a sanitized platform name for artifact naming
          PLATFORM=$(echo "${{ matrix.config.name }}" | tr '[:upper:]' '[:lower:]' | sed 's/ /_/g' | sed 's/[^a-z0-9_]/_/g')
          echo "PLATFORM=${PLATFORM}" >> $GITHUB_ENV

      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          # artifact name will be like build-ubuntu_gcc or build-macos_clang
          name: build-${{ env.PLATFORM }}
          path: ${{ github.workspace }}/install

  publish:
    name: Publish (version / tag / release)
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Checkout (fetch tags & history)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Download all build artifacts
        uses: actions/download-artifact@v4
        with:
          path: ./artifacts

      - name: Determine version and whether to push tag
        id: version
        shell: bash
        run: |
          set -euo pipefail

          # Determine current version: VERSION file > latest tag > 0.0.0
          if [ -f VERSION ]; then
            CURRENT=$(cat VERSION)
          else
            CURRENT=$(git describe --tags --abbrev=0 2>/dev/null || echo "0.0.0")
          fi
          CURRENT="${CURRENT#v}"
          echo "Current version: $CURRENT"

          SHOULD_PUSH=false
          VERSION="$CURRENT"

          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            # Manual dispatch: keep current version, do not push tag/commit
            echo "Manual dispatch: keeping version $VERSION"
            SHOULD_PUSH=false
          else
            # For push events: auto-bump patch only when not on a tag ref and not run by the bot
            if [[ "${GITHUB_REF}" == refs/tags/* ]]; then
              echo "Run is on a tag ref (${GITHUB_REF}); not bumping."
              SHOULD_PUSH=false
            elif [[ "${GITHUB_ACTOR}" == "github-actions[bot]" ]]; then
              echo "Run triggered by github-actions[bot]; not bumping."
              SHOULD_PUSH=false
            else
              IFS='.' read -r MAJ MIN PATCH <<< "${CURRENT}"
              MAJ=${MAJ:-0}; MIN=${MIN:-0}; PATCH=${PATCH:-0}
              PATCH=$((PATCH+1))
              VERSION="$MAJ.$MIN.$PATCH"
              SHOULD_PUSH=true
              echo "Auto-bumped version -> $VERSION"
            fi
          fi

          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "SHOULD_PUSH=$SHOULD_PUSH" >> $GITHUB_OUTPUT

          # persist VERSION file so it can be committed if needed
          echo "$VERSION" > VERSION

      - name: Commit VERSION and push tag (if auto-bumped)
        if: steps.version.outputs.SHOULD_PUSH == 'true'
        env:
          VERSION: ${{ steps.version.outputs.VERSION }}
          GIT_COMMITTER_NAME: "github-actions[bot]"
          GIT_COMMITTER_EMAIL: "github-actions[bot]@users.noreply.github.com"
        shell: bash
        run: |
          set -euo pipefail
          git config user.name "$GIT_COMMITTER_NAME"
          git config user.email "$GIT_COMMITTER_EMAIL"

          git add VERSION
          git commit -m "Bump version to v$VERSION" || echo "No changes to commit"

          TAG="v$VERSION"
          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "Tag $TAG already exists; skipping tag creation."
          else
            git tag -a "$TAG" -m "Release $TAG"
            # push commit and tags together
            git push origin HEAD --tags
          fi

      - name: Build release notes from commits
        id: notes
        shell: bash
        run: |
          set -euo pipefail
          TAG="v${{ steps.version.outputs.VERSION }}"

          # find previous tag (exclude current if just created)
          PREV_TAG=$(git describe --tags --abbrev=0 "$(git rev-list --tags --max-count=1)" 2>/dev/null || true)
          # if PREV_TAG is same as TAG, try to find previous before that
          if [ "$PREV_TAG" = "$TAG" ]; then
            PREV_TAG=$(git describe --tags --abbrev=0 "$(git rev-list --tags --skip=1 --max-count=1)" 2>/dev/null || true)
          fi

          if [ -n "$PREV_TAG" ] && [ "$PREV_TAG" != "$TAG" ]; then
            COMMITS=$(git log --no-merges --pretty=format:'- %s (%h)' "$PREV_TAG"..HEAD || true)
            RANGE_DESC="$PREV_TAG..HEAD"
          else
            COMMITS=$(git log --no-merges --pretty=format:'- %s (%h)' -n 50 HEAD || true)
            RANGE_DESC="recent commits"
          fi

          if [ -z "$COMMITS" ]; then
            COMMITS="No commit messages found (maybe only merge commits)."
          fi

          RELEASE_BODY=$(printf "Automated release for %s\n\nChanges (%s):\n%s\n\n(Release generated by CI)" "$TAG" "$RANGE_DESC" "$COMMITS")
          echo "body<<EOF" >> $GITHUB_OUTPUT
          echo "$RELEASE_BODY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create or update GitHub Release and get upload_url
        id: create_release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          VERSION: ${{ steps.version.outputs.VERSION }}
        shell: bash
        run: |
          set -euo pipefail
          TAG="v${VERSION}"

          # Build a safe release body (use printf with quoted variables so backticks in commits are NOT executed)
          PREV_TAG=$(git describe --tags --abbrev=0 "$(git rev-list --tags --max-count=1)" 2>/dev/null || true)
          if [ "$PREV_TAG" = "$TAG" ]; then
            PREV_TAG=$(git describe --tags --abbrev=0 "$(git rev-list --tags --skip=1 --max-count=1)" 2>/dev/null || true)
          fi

          if [ -n "$PREV_TAG" ] && [ "$PREV_TAG" != "$TAG" ]; then
            COMMITS=$(git log --no-merges --pretty=format:'- %s (%h)' "$PREV_TAG"..HEAD || true)
            RANGE_DESC="$PREV_TAG..HEAD"
          else
            COMMITS=$(git log --no-merges --pretty=format:'- %s (%h)' -n 50 HEAD || true)
            RANGE_DESC="recent commits"
          fi

          if [ -z "$COMMITS" ]; then
            COMMITS="No commit messages found (maybe only merge commits)."
          fi

          # Use printf with quoted args to prevent shell from interpreting backticks, dollar signs, etc.
          BODY=$(printf 'Automated release for %s\n\nChanges (%s):\n%s\n\n(Release generated by CI)' "$TAG" "$RANGE_DESC" "$COMMITS")

          # Build JSON payload using jq --arg so BODY is safely encoded as a JSON string
          PAYLOAD=$(jq -n --arg tag "$TAG" --arg name "$TAG" --arg body "$BODY" '{ tag_name: $tag, name: $name, body: $body, draft: false, prerelease: false }')

          # Create release (capture body + http code)
          CREATE_OUTPUT=$(curl -s -w "\n%{http_code}" -X POST \
            -H "Authorization: Bearer $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${{ github.repository }}/releases" \
            -d "$PAYLOAD")
          HTTP_CODE=$(echo "$CREATE_OUTPUT" | tail -n1)
          CREATE_BODY=$(echo "$CREATE_OUTPUT" | sed '$d')

          if [ "$HTTP_CODE" = "201" ]; then
            UPLOAD_URL=$(echo "$CREATE_BODY" | jq -r .upload_url)
            REL_ID=$(echo "$CREATE_BODY" | jq -r .id)
            echo "Created release $TAG (id=$REL_ID)"
          else
            # Try to get existing release by tag
            EXISTING=$(curl -s -H "Authorization: Bearer $GITHUB_TOKEN" -H "Accept: application/vnd.github+json" "https://api.github.com/repos/${{ github.repository }}/releases/tags/$TAG")
            REL_ID=$(echo "$EXISTING" | jq -r .id)
            UPLOAD_URL=$(echo "$EXISTING" | jq -r .upload_url)
            if [ "$REL_ID" = "null" ] || [ -z "$REL_ID" ]; then
              echo "Failed to create or find release for $TAG. HTTP $HTTP_CODE. Response: $CREATE_BODY"
              exit 1
            else
              # update release body
              UPDATE_PAYLOAD=$(jq -n --arg name "$TAG" --arg body "$BODY" '{ name: $name, body: $body }')
              curl -s -X PATCH -H "Authorization: Bearer $GITHUB_TOKEN" -H "Accept: application/vnd.github+json" "https://api.github.com/repos/${{ github.repository }}/releases/$REL_ID" -d "$UPDATE_PAYLOAD" >/dev/null
              echo "Found existing release $TAG (id=$REL_ID), updated body."
            fi
          fi

          # expose REL_ID and UPLOAD_URL (strip the {?name,label} suffix)
          CLEAN_UPLOAD_URL="${UPLOAD_URL%\{*}"
          echo "REL_ID=$REL_ID" >> $GITHUB_OUTPUT
          echo "UPLOAD_URL=$CLEAN_UPLOAD_URL" >> $GITHUB_OUTPUT


      - name: Attach artifacts to release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail
          REL_ID="${{ steps.create_release.outputs.REL_ID }}"
          UPLOAD_URL="${{ steps.create_release.outputs.UPLOAD_URL }}"

          if [ -z "$UPLOAD_URL" ] || [ -z "$REL_ID" ]; then
            echo "No upload URL or release id, skipping artifact upload."
            exit 0
          fi

          # iterate all files under ./artifacts and upload them
          find ./artifacts -type f | while read -r FILE; do
            BASENAME=$(basename "$FILE")
            echo "Processing $FILE -> $BASENAME"

            # remove existing asset with same name (to avoid duplicates)
            ASSET_ID=$(curl -s -H "Authorization: Bearer $GITHUB_TOKEN" -H "Accept: application/vnd.github+json" "https://api.github.com/repos/${{ github.repository }}/releases/$REL_ID/assets" | jq -r --arg name "$BASENAME" '.[] | select(.name == $name) | .id' | head -n1 || true)
            if [ -n "$ASSET_ID" ]; then
              echo "Deleting existing asset $BASENAME (id=$ASSET_ID)"
              curl -s -X DELETE -H "Authorization: Bearer $GITHUB_TOKEN" -H "Accept: application/vnd.github+json" "https://api.github.com/repos/${{ github.repository }}/releases/assets/$ASSET_ID"
            fi

            # upload the asset
            echo "Uploading $BASENAME ..."
            curl --silent --fail -X POST \
              -H "Authorization: Bearer $GITHUB_TOKEN" \
              -H "Content-Type: application/octet-stream" \
              --data-binary @"$FILE" \
              "$UPLOAD_URL?name=$(python3 -c 'import urllib.parse,sys;print(urllib.parse.quote(sys.argv[1]))' "$BASENAME")"
            if [ $? -eq 0 ]; then
              echo "Uploaded $BASENAME"
            else
              echo "Failed to upload $BASENAME"
            fi
          done

      - name: Done
        run: echo "Publish job finished."
